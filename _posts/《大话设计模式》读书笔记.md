---
title: 《大话设计模式》读书笔记
date: 2016-06-21 21:30:00
updated: 2020-04-30 22:39:01
categories: 编程
tags: [设计模式, 读书笔记]
---
## 面向对象基础
1. 类是对对象的抽象，抽象类是对类的抽象，接口是对行为的抽象。
2. 如果行为跨越不同类的对象，可使用接口；对于一些相似的类对象，用继承抽象类

抽象类是自底向上抽象出来的，接口是自顶向下的设计，也就是接口是预设计，抽象类是后抽象。
所有设计模式都是为了维护的方便，如果你的代码确定不需复用，阅后即焚，则设计模式是多余的。

敏捷开发：通过重构改善既有代码的设计

单一职责原则：就一个类应该只有一个引起它改变的原因

开放-封闭原则：对于扩展开发，对于更改封闭

依赖倒转原则：高层模块不应该依赖底层模块，两个都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。

里式代换原则：依赖父类则可用子类代替，反之则不可（子类型必需能够替换父类型）

迪米特法则：如果两个类不必彼此相互相互通信，那么这两个类就不应该发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法，可以通过第三者转发这个调用。

<!--more-->

## 各种设计模式
### 简单工厂
声明抽象产品父类，使用工厂生产具体的产品子类（根据条件进行判断）

### 策略模式
context类聚合抽象策略基类，并且含有目标方法，使用时将具体的策略实例传人context的构造方法，然后调用context的目标方法

### 策略与简单工厂结合
不向context传入具体策略实例，而是传入类型参数，然后在构造函数中根据参数新建相应的策略实例

### 装饰模式
装饰者和被装饰者继承同一基类，新建装饰者时将被装饰者作为参数传入，然后调用装饰者，关键是装饰者实现了被装饰者的功能。

### 代理模式
代理和使用代理者实现同一接口，使用代理者的所有操作都由代理执行（代理有使用代理者的引用）

### 工厂方法
具体工厂都实现了工厂方法接口，每个工厂负责一类产品，由客户端（用户）选择实例化哪个工厂。

### 原型模式
新实例是旧实例的一个复制，并不调用构造方法。试用于实例化开销比较大的场合。

### 模版方法
抽象类定义了算法骨架，子类重写特定步骤。

### 外观模式
子系统中有多个模块，定义外观类，整合了子系统中的方法，从而简化调用，类似点菜时直接点一个套餐。

### 建造者模式
抽象建造者定义建造各部分所需的方法，指挥者确定具体的建造步骤（引用抽象建造类），使用时传入具体建造类。

### 观察者模式
通知者持有每个观察者的引用，当被观察的资源或对象的状态发生改变时，通知者就通过notify方法调用每个观察者的相关方法通知观察者。

### 抽象工厂
抽象工厂有多个工厂方法，用以新建一个产品序列的多个产品，若有多个系列则可新建多个工厂子类。

### 状态模式
Context同组合state抽象类来表示各种状态，每个状态类都有相同方法的不同实现，这样可以通过改变state对象来改变操作。

### 适配器模式
适配器继承目标类，关联到被适配类，通过重新组合被适配类的方法来实现目标方法。

### 备忘录模式
发起者将自身状态传入备忘录的构造函数，并将备忘录对象由管理者持有；恢复时则从管理者处取出备忘录对象，调用备忘录的相关方法恢复数据。

### 组合模式
定义抽象类Composite，树叶和树枝都继承自Composite，树枝通过内部的list储存子节点，树叶和树枝（节点）实现相同的行为。
这样就可以将树叶和树枝都统一遍历。

### 迭代器模式
提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。

### 单例模式
使构造函数私有，提供一个getinstance方法获得实例，在getinstance方法内部判断是否新建实例。

### 桥接模式
桥的两侧都有很多地方，通过组合，实现多种多样的搭配。

### 命令模式
命令对象将命令执行者封装起来，并通过命令管理者来处理命令队列。

### 职责链模式
各个处理者继承自同一基类，并且他们处于同一条链上，设定某个条件，满足条件的处理者处理，否则转下一级。

### 中介者模式
用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用。

### 享元模式(fly weight)
享元工厂flyWeightFactory使用Hashtable记录已生成的各类实例，以降低实例化的损耗。

### 解释器模式
有终结符表达式类、非终结符表达式类，两者都继承自抽象表达式类，并且都实现了一个解释方法。

### 访问者模式
访问者种类固定，业务多变，定义业务类，将访问者作为对象传入。
